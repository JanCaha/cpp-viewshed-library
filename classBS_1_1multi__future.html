<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viewshed: BS::multi_future&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Viewshed
   </div>
   <div id="projectbrief">A C++ library for calculation of viewshed, inverse viewshed and visibility indices for both of those analyses.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceBS.html">BS</a></li><li class="navelem"><a class="el" href="classBS_1_1multi__future.html">multi_future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classBS_1_1multi__future-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BS::multi_future&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A helper class to facilitate waiting for and/or getting the results of multiple futures at once.  
 <a href="classBS_1_1multi__future.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BS__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BS::multi_future&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classBS_1_1multi__future__inherit__graph.png" border="0" usemap="#aBS_1_1multi__future_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for BS::multi_future&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classBS_1_1multi__future__coll__graph.png" border="0" usemap="#aBS_1_1multi__future_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ddf426156be078b1918f1748df212c5" id="r_a5ddf426156be078b1918f1748df212c5"><td class="memItemLeft" align="right" valign="top"><a id="a5ddf426156be078b1918f1748df212c5" name="a5ddf426156be078b1918f1748df212c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>multi_future</b> (const <a class="el" href="classBS_1_1multi__future.html">multi_future</a> &amp;)=delete</td></tr>
<tr class="separator:a5ddf426156be078b1918f1748df212c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97a4fac75449f078aeb3a64fb421d4d" id="r_ab97a4fac75449f078aeb3a64fb421d4d"><td class="memItemLeft" align="right" valign="top"><a id="ab97a4fac75449f078aeb3a64fb421d4d" name="ab97a4fac75449f078aeb3a64fb421d4d"></a>
<a class="el" href="classBS_1_1multi__future.html">multi_future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classBS_1_1multi__future.html">multi_future</a> &amp;)=delete</td></tr>
<tr class="separator:ab97a4fac75449f078aeb3a64fb421d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85edb185dd680718906d6f59156f82b" id="r_ac85edb185dd680718906d6f59156f82b"><td class="memItemLeft" align="right" valign="top"><a id="ac85edb185dd680718906d6f59156f82b" name="ac85edb185dd680718906d6f59156f82b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>multi_future</b> (<a class="el" href="classBS_1_1multi__future.html">multi_future</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac85edb185dd680718906d6f59156f82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cdd552e438b6c1e15949d9688acffb" id="r_a22cdd552e438b6c1e15949d9688acffb"><td class="memItemLeft" align="right" valign="top"><a id="a22cdd552e438b6c1e15949d9688acffb" name="a22cdd552e438b6c1e15949d9688acffb"></a>
<a class="el" href="classBS_1_1multi__future.html">multi_future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classBS_1_1multi__future.html">multi_future</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a22cdd552e438b6c1e15949d9688acffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b19061c7db1d50a35858e17dcd2268" id="r_ad2b19061c7db1d50a35858e17dcd2268"><td class="memItemLeft" align="right" valign="top">std::conditional_t&lt; std::is_void_v&lt; T &gt;, void, std::vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1multi__future.html#ad2b19061c7db1d50a35858e17dcd2268">get</a> ()</td></tr>
<tr class="memdesc:ad2b19061c7db1d50a35858e17dcd2268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the results from all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, rethrowing any stored exceptions.  <br /></td></tr>
<tr class="separator:ad2b19061c7db1d50a35858e17dcd2268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d35113924256a7449a02faf27e3de5f" id="r_a0d35113924256a7449a02faf27e3de5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1multi__future.html#a0d35113924256a7449a02faf27e3de5f">ready_count</a> () const</td></tr>
<tr class="memdesc:a0d35113924256a7449a02faf27e3de5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check how many of the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> are ready.  <br /></td></tr>
<tr class="separator:a0d35113924256a7449a02faf27e3de5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a5321e6be74bf09cb03514bf7cd42b" id="r_a39a5321e6be74bf09cb03514bf7cd42b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1multi__future.html#a39a5321e6be74bf09cb03514bf7cd42b">valid</a> () const</td></tr>
<tr class="memdesc:a39a5321e6be74bf09cb03514bf7cd42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> are valid.  <br /></td></tr>
<tr class="separator:a39a5321e6be74bf09cb03514bf7cd42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05073ed8d37b939c9440ac8789b69ba7" id="r_a05073ed8d37b939c9440ac8789b69ba7"><td class="memItemLeft" align="right" valign="top"><a id="a05073ed8d37b939c9440ac8789b69ba7" name="a05073ed8d37b939c9440ac8789b69ba7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> () const</td></tr>
<tr class="memdesc:a05073ed8d37b939c9440ac8789b69ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>. <br /></td></tr>
<tr class="separator:a05073ed8d37b939c9440ac8789b69ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381744c63b88eee1df425b5ce7b5e904" id="r_a381744c63b88eee1df425b5ce7b5e904"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:a381744c63b88eee1df425b5ce7b5e904"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1multi__future.html#a381744c63b88eee1df425b5ce7b5e904">wait_for</a> (const std::chrono::duration&lt; R, P &gt; &amp;duration) const</td></tr>
<tr class="memdesc:a381744c63b88eee1df425b5ce7b5e904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, but stop waiting after the specified duration has passed. This function first waits for the first future for the desired duration. If that future is ready before the duration expires, this function waits for the second future for whatever remains of the duration. It continues similarly until the duration expires.  <br /></td></tr>
<tr class="separator:a381744c63b88eee1df425b5ce7b5e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e095316d61714456281cb3d30325a1" id="r_ad7e095316d61714456281cb3d30325a1"><td class="memTemplParams" colspan="2">template&lt;typename C , typename D &gt; </td></tr>
<tr class="memitem:ad7e095316d61714456281cb3d30325a1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1multi__future.html#ad7e095316d61714456281cb3d30325a1">wait_until</a> (const std::chrono::time_point&lt; C, D &gt; &amp;timeout_time) const</td></tr>
<tr class="memdesc:ad7e095316d61714456281cb3d30325a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, but stop waiting after the specified time point has been reached. This function first waits for the first future until the desired time point. If that future is ready before the time point is reached, this function waits for the second future until the desired time point. It continues similarly until the time point is reached.  <br /></td></tr>
<tr class="separator:ad7e095316d61714456281cb3d30325a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class BS::multi_future&lt; T &gt;</div><p>A helper class to facilitate waiting for and/or getting the results of multiple futures at once. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The return type of the futures. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad2b19061c7db1d50a35858e17dcd2268" name="ad2b19061c7db1d50a35858e17dcd2268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b19061c7db1d50a35858e17dcd2268">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt; std::is_void_v&lt; T &gt;, void, std::vector&lt; T &gt; &gt; <a class="el" href="classBS_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the results from all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, rethrowing any stored exceptions. </p>
<dl class="section return"><dt>Returns</dt><dd>If the futures return <code>void</code>, this function returns <code>void</code> as well. Otherwise, it returns a vector containing the results. </dd></dl>

</div>
</div>
<a id="a0d35113924256a7449a02faf27e3de5f" name="a0d35113924256a7449a02faf27e3de5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d35113924256a7449a02faf27e3de5f">&#9670;&#160;</a></span>ready_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> <a class="el" href="classBS_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::ready_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check how many of the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> are ready. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of ready futures. </dd></dl>

</div>
</div>
<a id="a39a5321e6be74bf09cb03514bf7cd42b" name="a39a5321e6be74bf09cb03514bf7cd42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a5321e6be74bf09cb03514bf7cd42b">&#9670;&#160;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBS_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> are valid. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all futures are valid, <code>false</code> if at least one of the futures is not valid. </dd></dl>

</div>
</div>
<a id="a381744c63b88eee1df425b5ce7b5e904" name="a381744c63b88eee1df425b5ce7b5e904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381744c63b88eee1df425b5ce7b5e904">&#9670;&#160;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBS_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; R, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, but stop waiting after the specified duration has passed. This function first waits for the first future for the desired duration. If that future is ready before the duration expires, this function waits for the second future for whatever remains of the duration. It continues similarly until the duration expires. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>An arithmetic type representing the number of ticks to wait. </td></tr>
    <tr><td class="paramname">P</td><td>An <code>std::ratio</code> representing the length of each tick in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all futures have been waited for before the duration expired, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad7e095316d61714456281cb3d30325a1" name="ad7e095316d61714456281cb3d30325a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e095316d61714456281cb3d30325a1">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename C , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBS_1_1multi__future.html">BS::multi_future</a>&lt; T &gt;::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; C, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all the futures stored in this <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, but stop waiting after the specified time point has been reached. This function first waits for the first future until the desired time point. If that future is ready before the time point is reached, this function waits for the second future until the desired time point. It continues similarly until the time point is reached. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the clock used to measure time. </td></tr>
    <tr><td class="paramname">D</td><td>An <code>std::chrono::duration</code> type used to indicate the time point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>The time point at which to stop waiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all futures have been waited for before the time point was reached, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/cpp-viewshed-library/cpp-viewshed-library/include/viewshed/<a class="el" href="BS__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
