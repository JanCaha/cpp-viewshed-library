<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Viewshed: BS::thread_pool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Viewshed
   </div>
   <div id="projectbrief">A C++ library for calculation of viewshed, inverse viewshed and visibility indices for both of those analyses.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceBS.html">BS</a></li><li class="navelem"><a class="el" href="classBS_1_1thread__pool.html">thread_pool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classBS_1_1thread__pool-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BS::thread_pool Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A fast, lightweight, and easy-to-use C++17 thread pool class.  
 <a href="classBS_1_1thread__pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BS__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c6472571516f9b49eca3da136f85ad5" id="r_a5c6472571516f9b49eca3da136f85ad5"><td class="memItemLeft" align="right" valign="top"><a id="a5c6472571516f9b49eca3da136f85ad5" name="a5c6472571516f9b49eca3da136f85ad5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>thread_pool</b> ()</td></tr>
<tr class="memdesc:a5c6472571516f9b49eca3da136f85ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool. The number of threads will be the total number of hardware threads available, as reported by the implementation. This is usually determined by the number of cores in the CPU. If a core is hyperthreaded, it will count as two threads. <br /></td></tr>
<tr class="separator:a5c6472571516f9b49eca3da136f85ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a04950b2056561f02d6ac48d0d71c2" id="r_a82a04950b2056561f02d6ac48d0d71c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a82a04950b2056561f02d6ac48d0d71c2">thread_pool</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads)</td></tr>
<tr class="memdesc:a82a04950b2056561f02d6ac48d0d71c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified number of threads.  <br /></td></tr>
<tr class="separator:a82a04950b2056561f02d6ac48d0d71c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52daef5d90c48e7170aaf45c7448b22" id="r_ae52daef5d90c48e7170aaf45c7448b22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ae52daef5d90c48e7170aaf45c7448b22">thread_pool</a> (const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:ae52daef5d90c48e7170aaf45c7448b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified initialization function.  <br /></td></tr>
<tr class="separator:ae52daef5d90c48e7170aaf45c7448b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bbc2c2d583a6ffddde49ff056ec153" id="r_a11bbc2c2d583a6ffddde49ff056ec153"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a11bbc2c2d583a6ffddde49ff056ec153">thread_pool</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads, const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a11bbc2c2d583a6ffddde49ff056ec153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new thread pool with the specified number of threads and initialization function.  <br /></td></tr>
<tr class="separator:a11bbc2c2d583a6ffddde49ff056ec153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac11566157fc9fe4ab223d918e1d4cb" id="r_a2ac11566157fc9fe4ab223d918e1d4cb"><td class="memItemLeft" align="right" valign="top"><a id="a2ac11566157fc9fe4ab223d918e1d4cb" name="a2ac11566157fc9fe4ab223d918e1d4cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>thread_pool</b> (const <a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;)=delete</td></tr>
<tr class="separator:a2ac11566157fc9fe4ab223d918e1d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47c0cf9939c57f816cfacf30f75253f" id="r_ad47c0cf9939c57f816cfacf30f75253f"><td class="memItemLeft" align="right" valign="top"><a id="ad47c0cf9939c57f816cfacf30f75253f" name="ad47c0cf9939c57f816cfacf30f75253f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>thread_pool</b> (<a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ad47c0cf9939c57f816cfacf30f75253f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d37cad937327868131aeb99cc563294" id="r_a3d37cad937327868131aeb99cc563294"><td class="memItemLeft" align="right" valign="top"><a id="a3d37cad937327868131aeb99cc563294" name="a3d37cad937327868131aeb99cc563294"></a>
<a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;)=delete</td></tr>
<tr class="separator:a3d37cad937327868131aeb99cc563294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3657eafc6c8f95c6096b46a21ed8566e" id="r_a3657eafc6c8f95c6096b46a21ed8566e"><td class="memItemLeft" align="right" valign="top"><a id="a3657eafc6c8f95c6096b46a21ed8566e" name="a3657eafc6c8f95c6096b46a21ed8566e"></a>
<a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classBS_1_1thread__pool.html">thread_pool</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3657eafc6c8f95c6096b46a21ed8566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7cc32367d0d0c020bf103782506998" id="r_a1f7cc32367d0d0c020bf103782506998"><td class="memItemLeft" align="right" valign="top"><a id="a1f7cc32367d0d0c020bf103782506998" name="a1f7cc32367d0d0c020bf103782506998"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~thread_pool</b> ()</td></tr>
<tr class="memdesc:a1f7cc32367d0d0c020bf103782506998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the thread pool. Waits for all tasks to complete, then destroys all threads. Note that if the pool is paused, then any tasks still in the queue will never be executed. <br /></td></tr>
<tr class="separator:a1f7cc32367d0d0c020bf103782506998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5faf242cb0eacbb5c1142a2bd966468" id="r_ab5faf242cb0eacbb5c1142a2bd966468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468">get_tasks_queued</a> () const</td></tr>
<tr class="memdesc:ab5faf242cb0eacbb5c1142a2bd966468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently waiting in the queue to be executed by the threads.  <br /></td></tr>
<tr class="separator:ab5faf242cb0eacbb5c1142a2bd966468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b4d97e3a9e40e3228e2ed1f9a717cc" id="r_a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc">get_tasks_running</a> () const</td></tr>
<tr class="memdesc:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of tasks currently being executed by the threads.  <br /></td></tr>
<tr class="separator:a07b4d97e3a9e40e3228e2ed1f9a717cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdec64ff8998d66017cc185ae397e064" id="r_afdec64ff8998d66017cc185ae397e064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064">get_tasks_total</a> () const</td></tr>
<tr class="memdesc:afdec64ff8998d66017cc185ae397e064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <code><a class="el" href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a></code>.  <br /></td></tr>
<tr class="separator:afdec64ff8998d66017cc185ae397e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cb80839e30f218818e99af4d1dc64" id="r_afe1cb80839e30f218818e99af4d1dc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afe1cb80839e30f218818e99af4d1dc64">get_thread_count</a> () const</td></tr>
<tr class="memdesc:afe1cb80839e30f218818e99af4d1dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads in the pool.  <br /></td></tr>
<tr class="separator:afe1cb80839e30f218818e99af4d1dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa54345fcdcac73abeee62bc11359f85" id="r_afa54345fcdcac73abeee62bc11359f85"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::thread::id &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afa54345fcdcac73abeee62bc11359f85">get_thread_ids</a> () const</td></tr>
<tr class="memdesc:afa54345fcdcac73abeee62bc11359f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector containing the unique identifiers for each of the pool's threads, as obtained by <code>std::thread::get_id()</code>.  <br /></td></tr>
<tr class="separator:afa54345fcdcac73abeee62bc11359f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b0b929324dad46b60a0321477ca352" id="r_ab7b0b929324dad46b60a0321477ca352"><td class="memItemLeft" align="right" valign="top"><a id="ab7b0b929324dad46b60a0321477ca352" name="ab7b0b929324dad46b60a0321477ca352"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>purge</b> ()</td></tr>
<tr class="memdesc:ab7b0b929324dad46b60a0321477ca352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purge all the tasks waiting in the queue. Tasks that are currently running will not be affected, but any tasks still waiting in the queue will be discarded, and will never be executed by the threads. Please note that there is no way to restore the purged tasks. <br /></td></tr>
<tr class="separator:ab7b0b929324dad46b60a0321477ca352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1397ef0eaeeb370ae1e4a7ce7ab4f7" id="r_abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">detach_task</a> (F &amp;&amp;task BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with no arguments and no return value into the task queue, with the specified priority. To push a function with arguments, enclose it in a lambda expression. Does not return a future, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the task finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="separator:abd1397ef0eaeeb370ae1e4a7ce7ab4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c3c82e37e3f691455e24a3b590f8bc" id="r_ac4c3c82e37e3f691455e24a3b590f8bc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#ac4c3c82e37e3f691455e24a3b590f8bc">detach_blocks</a> (const T first_index, const T index_after_last, F &amp;&amp;block, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="separator:ac4c3c82e37e3f691455e24a3b590f8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae8dd7a78eae115aa90181cd6fef13e" id="r_aeae8dd7a78eae115aa90181cd6fef13e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:aeae8dd7a78eae115aa90181cd6fef13e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#aeae8dd7a78eae115aa90181cd6fef13e">detach_loop</a> (const T first_index, const T index_after_last, F &amp;&amp;loop, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:aeae8dd7a78eae115aa90181cd6fef13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="separator:aeae8dd7a78eae115aa90181cd6fef13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdad3e793adf525ccc220444940a882" id="r_a6bdad3e793adf525ccc220444940a882"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a6bdad3e793adf525ccc220444940a882"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a6bdad3e793adf525ccc220444940a882">detach_sequence</a> (const T first_index, const T index_after_last, F &amp;&amp;sequence BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:a6bdad3e793adf525ccc220444940a882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the sequence finishes executing, otherwise bad things will happen.  <br /></td></tr>
<tr class="separator:a6bdad3e793adf525ccc220444940a882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4172f1d76163c55e5d43e5835b23ef" id="r_a8b4172f1d76163c55e5d43e5835b23ef"><td class="memItemLeft" align="right" valign="top"><a id="a8b4172f1d76163c55e5d43e5835b23ef" name="a8b4172f1d76163c55e5d43e5835b23ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a8b4172f1d76163c55e5d43e5835b23ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with the total number of hardware threads available, as reported by the implementation. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. <br /></td></tr>
<tr class="separator:a8b4172f1d76163c55e5d43e5835b23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266a535346ea77b26da30a05a0f95a38" id="r_a266a535346ea77b26da30a05a0f95a38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a266a535346ea77b26da30a05a0f95a38">reset</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads)</td></tr>
<tr class="memdesc:a266a535346ea77b26da30a05a0f95a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with a new number of threads. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="separator:a266a535346ea77b26da30a05a0f95a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bdb7f9cb1520779c1a71f8c3123d34" id="r_a52bdb7f9cb1520779c1a71f8c3123d34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a52bdb7f9cb1520779c1a71f8c3123d34">reset</a> (const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a52bdb7f9cb1520779c1a71f8c3123d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with the total number of hardware threads available, as reported by the implementation, and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="separator:a52bdb7f9cb1520779c1a71f8c3123d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ebb337e3b7e4671352e4f3c67f7311" id="r_a45ebb337e3b7e4671352e4f3c67f7311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a45ebb337e3b7e4671352e4f3c67f7311">reset</a> (const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> num_threads, const std::function&lt; void()&gt; &amp;init_task)</td></tr>
<tr class="memdesc:a45ebb337e3b7e4671352e4f3c67f7311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pool with a new number of threads and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well.  <br /></td></tr>
<tr class="separator:a45ebb337e3b7e4671352e4f3c67f7311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d2e3f7c20e34fa24e33a7f6a417e44" id="r_af8d2e3f7c20e34fa24e33a7f6a417e44"><td class="memTemplParams" colspan="2">template&lt;typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;&gt;&gt; </td></tr>
<tr class="memitem:af8d2e3f7c20e34fa24e33a7f6a417e44"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#af8d2e3f7c20e34fa24e33a7f6a417e44">submit_task</a> (F &amp;&amp;task BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:af8d2e3f7c20e34fa24e33a7f6a417e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a function with no arguments into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an <code>std::future&lt;void&gt;</code> which can be used to wait until the task finishes.  <br /></td></tr>
<tr class="separator:af8d2e3f7c20e34fa24e33a7f6a417e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033e5571c8aa1649085b36544c73732a" id="r_a033e5571c8aa1649085b36544c73732a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </td></tr>
<tr class="memitem:a033e5571c8aa1649085b36544c73732a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a033e5571c8aa1649085b36544c73732a">submit_blocks</a> (const T first_index, const T index_after_last, F &amp;&amp;block, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:a033e5571c8aa1649085b36544c73732a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks.  <br /></td></tr>
<tr class="separator:a033e5571c8aa1649085b36544c73732a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef540eeab722bfc80c9c75924b2b563" id="r_afef540eeab722bfc80c9c75924b2b563"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afef540eeab722bfc80c9c75924b2b563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afef540eeab722bfc80c9c75924b2b563">submit_loop</a> (const T first_index, const T index_after_last, F &amp;&amp;loop, const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> num_blocks=0 BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:afef540eeab722bfc80c9c75924b2b563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. It must have no return value. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks.  <br /></td></tr>
<tr class="separator:afef540eeab722bfc80c9c75924b2b563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec05eedac7a0384b0f09b272cb5e0af" id="r_a0ec05eedac7a0384b0f09b272cb5e0af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T&gt;&gt; </td></tr>
<tr class="memitem:a0ec05eedac7a0384b0f09b272cb5e0af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a0ec05eedac7a0384b0f09b272cb5e0af">submit_sequence</a> (const T first_index, const T index_after_last, F &amp;&amp;sequence BS_THREAD_POOL_PRIORITY_INPUT)</td></tr>
<tr class="memdesc:a0ec05eedac7a0384b0f09b272cb5e0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the tasks.  <br /></td></tr>
<tr class="separator:a0ec05eedac7a0384b0f09b272cb5e0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8a0b066d078da097665ffadc475ae0" id="r_a9e8a0b066d078da097665ffadc475ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0">wait</a> ()</td></tr>
<tr class="memdesc:a9e8a0b066d078da097665ffadc475ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <code><a class="el" href="classBS_1_1thread__pool.html#af8d2e3f7c20e34fa24e33a7f6a417e44" title="Submit a function with no arguments into the task queue, with the specified priority....">submit_task()</a></code> instead, and call the <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> member function of the generated future.  <br /></td></tr>
<tr class="separator:a9e8a0b066d078da097665ffadc475ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8a4000155ecd7513b39093daaafc1d" id="r_afc8a4000155ecd7513b39093daaafc1d"><td class="memTemplParams" colspan="2">template&lt;typename R , typename P &gt; </td></tr>
<tr class="memitem:afc8a4000155ecd7513b39093daaafc1d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#afc8a4000155ecd7513b39093daaafc1d">wait_for</a> (const std::chrono::duration&lt; R, P &gt; &amp;duration)</td></tr>
<tr class="memdesc:afc8a4000155ecd7513b39093daaafc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified duration has passed.  <br /></td></tr>
<tr class="separator:afc8a4000155ecd7513b39093daaafc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467e8c017965228950dacdbc73f0ae9c" id="r_a467e8c017965228950dacdbc73f0ae9c"><td class="memTemplParams" colspan="2">template&lt;typename C , typename D &gt; </td></tr>
<tr class="memitem:a467e8c017965228950dacdbc73f0ae9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBS_1_1thread__pool.html#a467e8c017965228950dacdbc73f0ae9c">wait_until</a> (const std::chrono::time_point&lt; C, D &gt; &amp;timeout_time)</td></tr>
<tr class="memdesc:a467e8c017965228950dacdbc73f0ae9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for tasks to be completed, but stop waiting after the specified time point has been reached.  <br /></td></tr>
<tr class="separator:a467e8c017965228950dacdbc73f0ae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A fast, lightweight, and easy-to-use C++17 thread pool class. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a82a04950b2056561f02d6ac48d0d71c2" name="a82a04950b2056561f02d6ac48d0d71c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a04950b2056561f02d6ac48d0d71c2">&#9670;&#160;</a></span>thread_pool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified number of threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae52daef5d90c48e7170aaf45c7448b22" name="ae52daef5d90c48e7170aaf45c7448b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae52daef5d90c48e7170aaf45c7448b22">&#9670;&#160;</a></span>thread_pool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified initialization function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11bbc2c2d583a6ffddde49ff056ec153" name="a11bbc2c2d583a6ffddde49ff056ec153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11bbc2c2d583a6ffddde49ff056ec153">&#9670;&#160;</a></span>thread_pool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BS::thread_pool::thread_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new thread pool with the specified number of threads and initialization function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4c3c82e37e3f691455e24a3b590f8bc" name="ac4c3c82e37e3f691455e24a3b590f8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c3c82e37e3f691455e24a3b590f8bc">&#9670;&#160;</a></span>detach_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_blocks </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;BS_THREAD_POOL_PRIORITY_INPUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">block</td><td>A function that will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. <code>block(start, end)</code> should typically involve a loop of the form <code>for (T i = start; i &lt; end; ++i)</code>. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeae8dd7a78eae115aa90181cd6fef13e" name="aeae8dd7a78eae115aa90181cd6fef13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae8dd7a78eae115aa90181cd6fef13e">&#9670;&#160;</a></span>detach_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;BS_THREAD_POOL_PRIORITY_INPUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the loop finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no blocks will be submitted. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per index, many times per block. Should take exactly one argument: the loop index. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bdad3e793adf525ccc220444940a882" name="a6bdad3e793adf525ccc220444940a882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdad3e793adf525ccc220444940a882">&#9670;&#160;</a></span>detach_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_sequence </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;sequence&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Does not return a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code>, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the sequence finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function used to define the sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the sequence. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the sequence. The sequence will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no tasks will be submitted. </td></tr>
    <tr><td class="paramname">sequence</td><td>The function used to define the sequence. Will be called once per index. Should take exactly one argument, the index. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd1397ef0eaeeb370ae1e4a7ce7ab4f7" name="abd1397ef0eaeeb370ae1e4a7ce7ab4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1397ef0eaeeb370ae1e4a7ce7ab4f7">&#9670;&#160;</a></span>detach_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::detach_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;task&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with no arguments and no return value into the task queue, with the specified priority. To push a function with arguments, enclose it in a lambda expression. Does not return a future, so the user must use <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> or some other method to ensure that the task finishes executing, otherwise bad things will happen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to push. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the task. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5faf242cb0eacbb5c1142a2bd966468" name="ab5faf242cb0eacbb5c1142a2bd966468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5faf242cb0eacbb5c1142a2bd966468">&#9670;&#160;</a></span>get_tasks_queued()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::get_tasks_queued </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently waiting in the queue to be executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of queued tasks. </dd></dl>

</div>
</div>
<a id="a07b4d97e3a9e40e3228e2ed1f9a717cc" name="a07b4d97e3a9e40e3228e2ed1f9a717cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b4d97e3a9e40e3228e2ed1f9a717cc">&#9670;&#160;</a></span>get_tasks_running()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::get_tasks_running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of tasks currently being executed by the threads. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of running tasks. </dd></dl>

</div>
</div>
<a id="afdec64ff8998d66017cc185ae397e064" name="afdec64ff8998d66017cc185ae397e064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdec64ff8998d66017cc185ae397e064">&#9670;&#160;</a></span>get_tasks_total()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a> BS::thread_pool::get_tasks_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread. Note that <code><a class="el" href="classBS_1_1thread__pool.html#afdec64ff8998d66017cc185ae397e064" title="Get the total number of unfinished tasks: either still waiting in the queue, or running in a thread....">get_tasks_total()</a> == <a class="el" href="classBS_1_1thread__pool.html#ab5faf242cb0eacbb5c1142a2bd966468" title="Get the number of tasks currently waiting in the queue to be executed by the threads.">get_tasks_queued()</a> + <a class="el" href="classBS_1_1thread__pool.html#a07b4d97e3a9e40e3228e2ed1f9a717cc" title="Get the number of tasks currently being executed by the threads.">get_tasks_running()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The total number of tasks. </dd></dl>

</div>
</div>
<a id="afe1cb80839e30f218818e99af4d1dc64" name="afe1cb80839e30f218818e99af4d1dc64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cb80839e30f218818e99af4d1dc64">&#9670;&#160;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a> BS::thread_pool::get_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads in the pool. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads. </dd></dl>

</div>
</div>
<a id="afa54345fcdcac73abeee62bc11359f85" name="afa54345fcdcac73abeee62bc11359f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa54345fcdcac73abeee62bc11359f85">&#9670;&#160;</a></span>get_thread_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::thread::id &gt; BS::thread_pool::get_thread_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector containing the unique identifiers for each of the pool's threads, as obtained by <code>std::thread::get_id()</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique thread identifiers. </dd></dl>

</div>
</div>
<a id="a266a535346ea77b26da30a05a0f95a38" name="a266a535346ea77b26da30a05a0f95a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266a535346ea77b26da30a05a0f95a38">&#9670;&#160;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with a new number of threads. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45ebb337e3b7e4671352e4f3c67f7311" name="a45ebb337e3b7e4671352e4f3c67f7311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ebb337e3b7e4671352e4f3c67f7311">&#9670;&#160;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#a7bb1747ef283bd1349183c445ee89aaa">concurrency_t</a>&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with a new number of threads and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_threads</td><td>The number of threads to use. </td></tr>
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52bdb7f9cb1520779c1a71f8c3123d34" name="a52bdb7f9cb1520779c1a71f8c3123d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bdb7f9cb1520779c1a71f8c3123d34">&#9670;&#160;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::reset </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>init_task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the pool with the total number of hardware threads available, as reported by the implementation, and a new initialization function. Waits for all currently running tasks to be completed, then destroys all threads in the pool and creates a new thread pool with the new number of threads and initialization function. Any tasks that were waiting in the queue before the pool was reset will then be executed by the new threads. If the pool was paused before resetting it, the new pool will be paused as well. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_task</td><td>An initialization function to run in each thread before it starts to execute any submitted tasks. The function must take no arguments and have no return value. It will only be executed exactly once, when the thread is first constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a033e5571c8aa1649085b36544c73732a" name="a033e5571c8aa1649085b36544c73732a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033e5571c8aa1649085b36544c73732a">&#9670;&#160;</a></span>submit_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; R &gt; BS::thread_pool::submit_blocks </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;BS_THREAD_POOL_PRIORITY_INPUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The block function takes two arguments, the start and end of the block, so that it is only called only once per block, but it is up to the user make sure the block function correctly deals with all the indices in each block. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function to loop through (can be <code>void</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no blocks will be submitted, and an empty <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> will be returned. </td></tr>
    <tr><td class="paramname">block</td><td>A function that will be called once per block. Should take exactly two arguments: the first index in the block and the index after the last index in the block. <code>block(start, end)</code> should typically involve a loop of the form <code>for (T i = start; i &lt; end; ++i)</code>. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that can be used to wait for all the blocks to finish. If the block function returns a value, the <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> can also be used to obtain the values returned by each block. </dd></dl>

</div>
</div>
<a id="afef540eeab722bfc80c9c75924b2b563" name="afef540eeab722bfc80c9c75924b2b563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef540eeab722bfc80c9c75924b2b563">&#9670;&#160;</a></span>submit_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; void &gt; BS::thread_pool::submit_loop </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceBS.html#add93ee37fb219bcd3f78de80d002c249">size_t</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0&#160;BS_THREAD_POOL_PRIORITY_INPUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parallelize a loop by automatically splitting it into blocks and submitting each block separately to the queue, with the specified priority. The loop function takes one argument, the loop index, so that it is called many times per block. It must have no return value. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the blocks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function to loop through. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the loop. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the loop. The loop will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no tasks will be submitted, and an empty <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> will be returned. </td></tr>
    <tr><td class="paramname">loop</td><td>The function to loop through. Will be called once per index, many times per block. Should take exactly one argument: the loop index. It cannot have a return value. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The maximum number of blocks to split the loop into. The default is 0, which means the number of blocks will be equal to the number of threads in the pool. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that can be used to wait for all the blocks to finish. </dd></dl>

</div>
</div>
<a id="a0ec05eedac7a0384b0f09b272cb5e0af" name="a0ec05eedac7a0384b0f09b272cb5e0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec05eedac7a0384b0f09b272cb5e0af">&#9670;&#160;</a></span>submit_sequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;, T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBS_1_1multi__future.html">multi_future</a>&lt; R &gt; BS::thread_pool::submit_sequence </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>first_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>index_after_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;sequence&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a sequence of tasks enumerated by indices to the queue, with the specified priority. Returns a <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that contains the futures for all of the tasks. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the indices. Should be a signed or unsigned integer. </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function used to define the sequence. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function used to define the sequence (can be <code>void</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_index</td><td>The first index in the sequence. </td></tr>
    <tr><td class="paramname">index_after_last</td><td>The index after the last index in the sequence. The sequence will iterate from <code>first_index</code> to <code>(index_after_last - 1)</code> inclusive. In other words, it will be equivalent to <code>for (T i = first_index; i &lt; index_after_last; ++i)</code>. Note that if <code>index_after_last &lt;= first_index</code>, no tasks will be submitted, and an empty <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> will be returned. </td></tr>
    <tr><td class="paramname">sequence</td><td>The function used to define the sequence. Will be called once per index. Should take exactly one argument, the index. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the tasks. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> that can be used to wait for all the tasks to finish. If the sequence function returns a value, the <code><a class="el" href="classBS_1_1multi__future.html" title="A helper class to facilitate waiting for and/or getting the results of multiple futures at once.">multi_future</a></code> can also be used to obtain the values returned by each task. </dd></dl>

</div>
</div>
<a id="af8d2e3f7c20e34fa24e33a7f6a417e44" name="af8d2e3f7c20e34fa24e33a7f6a417e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d2e3f7c20e34fa24e33a7f6a417e44">&#9670;&#160;</a></span>submit_task()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename R  = std::invoke_result_t&lt;std::decay_t&lt;F&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt; R &gt; BS::thread_pool::submit_task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;task&#160;</td>
          <td class="paramname"><em>BS_THREAD_POOL_PRIORITY_INPUT</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Submit a function with no arguments into the task queue, with the specified priority. To submit a function with arguments, enclose it in a lambda expression. If the function has a return value, get a future for the eventual returned value. If the function has no return value, get an <code>std::future&lt;void&gt;</code> which can be used to wait until the task finishes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function. </td></tr>
    <tr><td class="paramname">R</td><td>The return type of the function (can be <code>void</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The function to submit. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the task. Should be between -32,768 and 32,767 (a signed 16-bit integer). The default is 0. Only enabled if <code>BS_THREAD_POOL_ENABLE_PRIORITY</code> is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A future to be used later to wait for the function to finish executing and/or obtain its returned value if it has one. </dd></dl>

</div>
</div>
<a id="a9e8a0b066d078da097665ffadc475ae0" name="a9e8a0b066d078da097665ffadc475ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8a0b066d078da097665ffadc475ae0">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BS::thread_pool::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are currently running in the threads and those that are still waiting in the queue. However, if the pool is paused, this function only waits for the currently running tasks (otherwise it would wait forever). Note: To wait for just one specific task, use <code><a class="el" href="classBS_1_1thread__pool.html#af8d2e3f7c20e34fa24e33a7f6a417e44" title="Submit a function with no arguments into the task queue, with the specified priority....">submit_task()</a></code> instead, and call the <code><a class="el" href="classBS_1_1thread__pool.html#a9e8a0b066d078da097665ffadc475ae0" title="Wait for tasks to be completed. Normally, this function waits for all tasks, both those that are curr...">wait()</a></code> member function of the generated future. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`wait_deadlock`</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if <code>BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc8a4000155ecd7513b39093daaafc1d" name="afc8a4000155ecd7513b39093daaafc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8a4000155ecd7513b39093daaafc1d">&#9670;&#160;</a></span>wait_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::wait_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; R, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>duration</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified duration has passed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>An arithmetic type representing the number of ticks to wait. </td></tr>
    <tr><td class="paramname">P</td><td>An <code>std::ratio</code> representing the length of each tick in seconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>The amount of time to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tasks finished running, <code>false</code> if the duration expired but some tasks are still running.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`wait_deadlock`</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if <code>BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a467e8c017965228950dacdbc73f0ae9c" name="a467e8c017965228950dacdbc73f0ae9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467e8c017965228950dacdbc73f0ae9c">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , typename D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool BS::thread_pool::wait_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; C, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for tasks to be completed, but stop waiting after the specified time point has been reached. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The type of the clock used to measure time. </td></tr>
    <tr><td class="paramname">D</td><td>An <code>std::chrono::duration</code> type used to indicate the time point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_time</td><td>The time point at which to stop waiting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all tasks finished running, <code>false</code> if the time point was reached but some tasks are still running.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">`wait_deadlock`</td><td>if called from within a thread of the same pool, which would result in a deadlock. Only enabled if <code>BS_THREAD_POOL_ENABLE_WAIT_DEADLOCK_CHECK</code> is defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/cpp-viewshed-library/cpp-viewshed-library/include/viewshed/<a class="el" href="BS__thread__pool_8hpp_source.html">BS_thread_pool.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
